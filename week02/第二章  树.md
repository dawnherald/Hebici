# 第二章  树

## 1.二叉树

### 1.1平均情况的讨论

二叉树中的操作，基本都是递归到某一深处的结点，然后执行操作。

所以算法复杂度 应该为 递归次数*下降深度的花费

递归的次数则为内部路径长，即为深度。

1.1.1 如何证明树的每个结点的平均深度为NlogN

可以以主函数方法思考，每一层有2^n个结点，每个结点会被分为N/2d的规模。

缺陷：CRUT会逐渐改变树的结构 增加开销

## 2.AVL树

保证M次操作花费为MlogN。

通过对插入 和 删除的改动，使得每个节点的左右高度差≤1.



分为四种情况： 左左，左右 ，右左，右右。分别用一次单旋转，和双旋转完成。

使用场景：AVL树的ID操作开销巨大，因此适合于不经常改变的树。

### 1.关于AVL树的高度信息保存。

如果用1，0等标记某个节点左右子树的差，会让程序变得难以阅读。相反，每个节点直接存储其高度信息。

### 编程中的问题：

插入历程：

1.高度信息如何进行增加？

自己的思路： 每次插入对途径结点高度加1.

2.如何判断是左左、左右区分。

```c
//插入后是左子树改变，因此只需要判断左子树减去右子树搞得差距
		if (Height(B->Left) - Height(B->right) == 2)
		{
            //需要旋转时，一定是父节点B的左右子树高度差有问题，因此 左子树改变了高度信息，我们只考虑左左，左右
            //Avl树保证结点左右左子树高度差不超过1，因此旋转一定在三个节点以内发生。
            //
			if (x<B->Left->Elmement)
			{
				B=SingleRotateLeft(B);
			}
			else
			{
				B=DoubleRotateRight(B;
			}
		}
```

3.单旋转中，一定要将旋转后的主节点赋值给插入历程的形参，否则会造成结点丢失。

4.出现C2040　间接寻址级别不同

原因： 在插入调用的旋转函数未在其函数前定义，导致错误。

### 2.ＡＶＬ树的遍历

１．前序

每次遍历，先写该节点的左子树，中间结点，右子树

```

```

２．后序



３．中序



４．层序

层序遍历，需要用到队列的结构。（）

1.队列再每层递归的插入左右子树

2.通过FIFO依次弹出，先弹出左子树以此递归。

```

```

## 3.伸展树

 伸展树是二叉查找树的同类树

优势是可以保证M次操作花费为MlogN。其实际花费在logn与N之间，所以描述的花费未摊还代价。

### 1.实现思路：

通过将访问的对象移动到根结点，在移动的过程会改变树的结构，使树的深度为原来一半。

### 2.展开

1.一字型

需要将左子树转换为右子树。

疑问：

可否从查找的目标节点父节点开始进行单旋转？

2.之字型

采用双旋转即可

### 3.删除

将访问节点移动到根后，删除该节点，将左子树的最大值移动到根结点。



## 课后练习：

#### 4.20非懒惰AVL树删除

AVL树删除节点的过程是，先找到该节点，然后进行删除。由于删除节点的位置不同，导致删除后节点进行移动的方式不同。删除节点的位置分为以下4类：

1.**删除叶子结点**。操作：直接删除，然后依次向上调整为AVL树。

2.**删除非叶子节点，该节点只有左孩子**。操作：该节点的值替换为左孩子节点的值，然后删除左孩子节点。【左孩子节点为叶子结点，所以删除左孩子节点的情况为第1种情况。】【为什么左孩子节点为叶子节点，因为删除节点前，该树是AVL树，由AVL树的定义知，每个节点的左右子树的高度差的绝对值<=1,由于该节点只有左孩子，没有右孩子，如果左孩子还有子节点，那么将不满足每个节点的左右子树的高度差的绝对值<=1，所以左孩子节点为叶子结点】

3.**删除非叶子节点，该节点只有右孩子。**操作：该节点的值替换为右孩子节点的值，然后删除右孩子节点。【右孩子节点为叶子结点，所以删除右孩子节点的情况为第1种情况。】【为什么右孩子节点为叶子节点？答案和第二种情况一样】

4.**删除非叶子节点，该节点既有左孩子，又有右孩子。**操作：该节点的值替换为该节点的前驱节点（或者后继节点），然后删除前驱节点（或者后继节点）。【前驱结点:在中序遍历中，一个节点的前驱结点，先找到该节点的左孩子节点，再找左孩子节点的最后一个右孩子节点。向左走一步，然后向右走到头。最后一个右孩子节点即为前驱节点】【后继节点：在中序遍历中，一个节点的后继结点，先找到该节点的右孩子节点，再找右孩子节点的最后一个左孩子节点。向右走一步，然后向左走到头。最后一个左孩子节点即为前驱节点】
————————————————
版权声明：本文为CSDN博主「Adsh」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_21388535/article/details/105601270

#### 4.22 双旋转

手写两个单旋转历程即可

#### 4.28遍历节点个数

结点：递归查找

叶子:

1. 满节点递归左右子树
2. 叶子结点返回数字
3. 只有一个儿子情况则继续遍历。

#### 4.29

思路一： 选取范围中点，然后左右不断插入 复杂度为 N*Nlog（N）。

思路二： 类似于快排的思想，第一次插入中点作为根结点，然后递归在左子树的根，右子树的根，插入左范围，右范围的重点。一次类推。

如果范围是偶数个，则随机取一个。

思路三：数字按照层序遍历放入队列 最后依次取出。

#### 4.30



#### 4.31







