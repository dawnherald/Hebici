# 第七章 排序算法

## 1.插入排序

###  思想：

第i躺排序时，保证在i之前的数组已经排序。

### 实现：

```c
void InsertSort(int *Array , int length)
{
	for (int i = 0; i < length; i++)
	{
		for (int j = i + 1; j > 0 && j < length; j--)
		{
			int temp = Array[j];
			if (Array[j] < Array[j - 1])
			{
				Array[j] = Array[j - 1];
				Array[j - 1] = temp;
			}
		}
	}
}
```



## 2.希尔排序：

### 思想：

缩减增量排序。每次排序，选取一定的间隔进行排序，最终间隔缩减到1保证所有的数据得到排序。

### 实现:

1.希尔排序的关键在于增量的选择，可以决定算法的速度。

2.希尔排序将间隔N、N+1、、、、、L-1位置上i的元素放到i、i-N、i-2*N。

本质是将Hk哥独立数组进行一次插入排序。

```c
void ShellSort(int* Array, int Length)
{
	int gap, temp, j;
	//增量缩小排序
	//gap 的选取值会影响算法快慢
	for (gap = Length /2;gap>=1;gap/=2 )
		//将gap——gap+n上的元素放到 i - N*gap上。
		for (int i = gap; i < Length; i++)
		{
			temp = Array[i];
			for ( j = i; i > 0; j -= gap)
			{
				if (temp < Array[j-gap])
				{
					Array[j] = Array[j - gap];
				}
				else
				{
					break;
				}
			}
			Array[j] = temp;
		}
}
```

### 讨论：

1.希尔排序最坏为N^2

## 3.堆排序

### 思想：

采用二叉堆的插入，建立二叉堆（花费N），再执行DeletMin，将最小元素放入一个额外数组，实现排序。

**关键点：二叉堆的线性建立**

二叉堆建立如果进行循环插入则为Nlogn很显然不符合堆排序的思想。

如何实现？

```

```

改进：

放入数组会导致多耗费空间。

可以将位于堆最后的元素保存删除的元素。

### 实现

二叉堆的线性建立！！！

```

```

目前暂不知道如何线性建立二叉堆。在网上学习了另一种思路：https://www.cnblogs.com/chengxiao/p/6129630.html

再简单总结下堆排序的基本思路：

　　**a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;**

　　**b.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;**

　　**c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。**

```c
void adjustHeap(int arr[],int i , int length)
{
    int temp = arr[i];//先取出当前元素i
    for (int k = i * 2 + 1; k < length; k = k * 2 + 1) {//从i结点的左子结点开始，也就是2i+1处开始
        if (k + 1 < length && arr[k] < arr[k + 1]) {//如果左子结点小于右子结点，k指向右子结点
            k++;
        }
        if (arr[k] > temp) {//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）
            arr[i] = arr[k];
            i = k;
        }
        else {
            break;
        }
    }
    arr[i] = temp;//将temp值放到最终的位置
}
```



# 代码实现

## 4.归并排序

### 思想：

归并排序是最坏时间界为nlogn的递归算法。归并是对两个已经排序的数组进行比较并复制到额外空间，当一个数组读取完后，另个数组直接复制到额外空间。

递归实现 需要运用的分治思想，将数组分为很小的部分，进行归并排序。

### 实现疑问： 

1.当为void无返回值，如何将每次分支后排序的结果得到？？

2.

### 实现细节：

```

```

### 归并讨论：

书中主要讨论了如何将 T(n)=2T(n/2)+n进行计算。

第一种方法： 类似于迭代思想，将等式左边除以N，然后将系数换位N/2^i。最终得到的一系列式子。

第二种方法：按照递归式子不断化简最终得到等式表达式。

## 5.快速排序(quicksort)

平均运行时间nlogn，优化后可可避免最坏N^2的递归算法。

### 思想：

![img](file:///C:\Users\Hasee\AppData\Roaming\Tencent\Users\2257714950\QQ\WinTemp\RichOle\2]E40GH_[B6~FW1_VXR9V}H.png)

快排虽然和合并排序同为分支递归算法。但快排分割的两个子问题不具有同等大小，当选取的合适的枢纽元，可以弥补递归调用的花费。

### 关键点：

#### 1.枢纽元的选择

1.错误： 选取第一个元素

2.安全：随机函数选取枢纽元

3.三数中值分割 一般选取 L R C 三个位置。

#### 2.分割策略

1.将枢纽元放到数组末端，分离要分开的数组。

（个人想法：是声名两个数组，然后用枢纽元分配最后Merge。）

2.i从0开始，j从L-2开始。当i遇到大于枢纽元的数字不动，否则右移，当j遇到小于枢纽元的数字不动，否则左移。然后交换i , j 

3.当i=j则于枢纽元交换位置。

**问题：当遇到于枢纽元相同元素，i j如何选择。**

### 实现

1.枢纽元的选取。可以优化一下，在获取枢纽元阶段，将数字大小进行排序。

2.分割策略：

```

```

细节：

![img](file:///C:\Users\Hasee\AppData\Roaming\Tencent\Users\2257714950\QQ\WinTemp\RichOle\O1UOYDE}O%}G26V5J3`PY8F.png)

问题：

&引用与指针的关系？

&作为形参的意义？

### 选择的线性期望时间算法

待看

## 6.桶排序

特定用途下可以常数复杂度实现排序的算法

## 7.外部排序